{
  "resolvedId": "D:/Projects/Web Dev/fu-mission-board-nuxt/node_modules/markdown-it/lib/rules_block/table.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nexport default function table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n",
      "start": 1711658792319,
      "end": 1711658792341,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1711658792341,
      "end": 1711658792341,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1711658792342,
      "end": 1711658792342,
      "order": "normal"
    }
  ]
}
